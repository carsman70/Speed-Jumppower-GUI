-- FINAL: Updated GUI with non-deletable invite, typed value validation, snap=5, always-on-top (DisplayOrder lowered, loading bar removed)
-- Paste into StarterPlayerScripts (replace previous LocalScript)

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local TextService = game:GetService("TextService")

local player = Players.LocalPlayer
local playerGui = player:WaitForChild("PlayerGui")

-- CONFIG
local DEFAULT_SPEED = 16
local DEFAULT_JUMP = 50
local MAX_VALUE = 1000
local SNAP = 5                -- snapping every 5 units
local DISCORD_INVITE = "https://discord.gg/Gq2nNUac4"

-- FRAME
local FRAME_W, FRAME_H = 360, 240
local mainFrame = Instance.new("Frame")
mainFrame.Name = "MainFrame"
mainFrame.Size = UDim2.new(0, FRAME_W, 0, FRAME_H)
mainFrame.Position = UDim2.new(0.5, -FRAME_W/2, 0.45, -FRAME_H/2)
mainFrame.BackgroundColor3 = Color3.fromRGB(12,12,12)
mainFrame.BackgroundTransparency = 0.18
mainFrame.BorderSizePixel = 0
mainFrame.ClipsDescendants = true
mainFrame.Visible = true -- show immediately (no loading bar)
mainFrame.Parent = screenGui
local corner = Instance.new("UICorner", mainFrame)
corner.CornerRadius = UDim.new(0, 10)

-- TITLEBAR
local titleBar = Instance.new("Frame")
titleBar.Name = "TitleBar"
titleBar.Size = UDim2.new(1, 0, 0, 36)
titleBar.Position = UDim2.new(0, 0, 0, 0)
titleBar.BackgroundTransparency = 1
titleBar.Parent = mainFrame

local titleLabel = Instance.new("TextLabel")
titleLabel.Name = "TitleLabel"
titleLabel.Size = UDim2.new(0.6, -12, 1, 0)
titleLabel.Position = UDim2.new(0, 12, 0, 0)
titleLabel.BackgroundTransparency = 1
titleLabel.Text = "ScriptBlock"
titleLabel.TextColor3 = Color3.new(1,1,1)
titleLabel.Font = Enum.Font.GothamBold
titleLabel.TextSize = 16
titleLabel.TextXAlignment = Enum.TextXAlignment.Left
titleLabel.Parent = titleBar

-- Minimize & Close
local minBtn = Instance.new("TextButton")
minBtn.Name = "Minimize"
minBtn.Size = UDim2.new(0, 30, 0, 26)
minBtn.Position = UDim2.new(1, -76, 0, 5)
minBtn.BackgroundColor3 = Color3.fromRGB(70,70,70)
minBtn.Text = "â€”"
minBtn.TextColor3 = Color3.new(1,1,1)
minBtn.Font = Enum.Font.GothamBold
minBtn.TextSize = 16
minBtn.Parent = titleBar
local minCorner = Instance.new("UICorner", minBtn)
minCorner.CornerRadius = UDim.new(0,6)

local closeBtn = Instance.new("TextButton")
closeBtn.Name = "Close"
closeBtn.Size = UDim2.new(0, 30, 0, 26)
closeBtn.Position = UDim2.new(1, -40, 0, 5)
closeBtn.BackgroundColor3 = Color3.fromRGB(140,20,20)
closeBtn.Text = "X"
closeBtn.TextColor3 = Color3.new(1,1,1)
closeBtn.Font = Enum.Font.GothamBold
closeBtn.TextSize = 16
closeBtn.Parent = titleBar
local closeCorner = Instance.new("UICorner", closeBtn)
closeCorner.CornerRadius = UDim.new(0,6)

-- BODY
local body = Instance.new("Frame")
body.Name = "Body"
body.Size = UDim2.new(1, 0, 1, -36)
body.Position = UDim2.new(0, 0, 0, 36)
body.BackgroundTransparency = 1
body.Parent = mainFrame

-- CONTROLS (visible immediately)
local controlsFrame = Instance.new("Frame")
controlsFrame.Name = "Controls"
controlsFrame.Size = UDim2.new(1, -24, 0, 120)
controlsFrame.Position = UDim2.new(0, 12, 0, 12)
controlsFrame.BackgroundTransparency = 1
controlsFrame.Visible = true
controlsFrame.Parent = body

-- Helper: slider row with improved smaller value box
local function createSliderRow(parent, y, labelText, default)
    local row = Instance.new("Frame")
    row.Size = UDim2.new(1, 0, 0, 40)
    row.Position = UDim2.new(0, 0, 0, y)
    row.BackgroundTransparency = 1
    row.Parent = parent

    local lbl = Instance.new("TextLabel")
    lbl.Size = UDim2.new(0, 100, 1, 0)
    lbl.Position = UDim2.new(0, 0, 0, 0)
    lbl.BackgroundTransparency = 1
    lbl.Text = labelText
    lbl.TextColor3 = Color3.new(1,1,1)
    lbl.Font = Enum.Font.Gotham
    lbl.TextSize = 14
    lbl.TextXAlignment = Enum.TextXAlignment.Left
    lbl.Parent = row

    -- SMALLER value box sized for "1000"
    local valueBox = Instance.new("TextBox")
    local sampleSize = TextService:GetTextSize("1000", 14, Enum.Font.Gotham, Vector2.new(1000, 1000))
    local boxWidth = math.clamp(math.ceil(sampleSize.X) + 10, 36, 64) -- fit 1000, min 36 max 64
    valueBox.Size = UDim2.new(0, boxWidth, 1, -6)
    valueBox.Position = UDim2.new(1, - (boxWidth + 16), 0, 3) -- moved slightly left
    valueBox.BackgroundTransparency = 0.3
    valueBox.Text = tostring(default)
    valueBox.ClearTextOnFocus = false
    valueBox.Font = Enum.Font.Gotham
    valueBox.TextSize = 14
    valueBox.TextColor3 = Color3.new(1,1,1)
    valueBox.TextXAlignment = Enum.TextXAlignment.Center
    valueBox.Parent = row
    local vbCorner = Instance.new("UICorner", valueBox)
    vbCorner.CornerRadius = UDim.new(0,6)

    local track = Instance.new("Frame")
    track.Size = UDim2.new(1, -170, 0, 12)
    track.Position = UDim2.new(0, 110, 0, 14)
    track.BackgroundColor3 = Color3.fromRGB(120,120,120)
    track.BorderSizePixel = 0
    track.Parent = row
    local trCorner = Instance.new("UICorner", track)
    trCorner.CornerRadius = UDim.new(0, 6)

    local fill = Instance.new("Frame")
    fill.Size = UDim2.new(default / MAX_VALUE, 0, 1, 0)
    fill.Position = UDim2.new(0, 0, 0, 0)
    fill.BackgroundColor3 = Color3.fromRGB(190,190,190)
    fill.BorderSizePixel = 0
    fill.Parent = track
    local fillCorner2 = Instance.new("UICorner", fill)
    fillCorner2.CornerRadius = UDim.new(0, 6)

    local knob = Instance.new("ImageButton")
    knob.Size = UDim2.new(0, 18, 0, 18)
    knob.AnchorPoint = Vector2.new(0.5, 0.5)
    knob.Position = UDim2.new(default / MAX_VALUE, 0, 0.5, 0)
    knob.BackgroundColor3 = Color3.fromRGB(230,230,230)
    knob.BorderSizePixel = 0
    knob.Parent = track
    local knobCorner = Instance.new("UICorner", knob)
    knobCorner.CornerRadius = UDim.new(0, 9)
    knob.AutoButtonColor = false

    return {
        Row = row,
        Label = lbl,
        ValueBox = valueBox,
        Track = track,
        Fill = fill,
        Knob = knob,
        Value = default,
        Dragging = false,
        SavedValue = default -- store last valid value
    }
end

local speedRow = createSliderRow(controlsFrame, 0, "Speed", DEFAULT_SPEED)
local jumpRow = createSliderRow(controlsFrame, 44, "JumpPower", DEFAULT_JUMP)

-- REVERT button
local revertBtn = Instance.new("TextButton")
revertBtn.Size = UDim2.new(0, 86, 0, 30)
revertBtn.Position = UDim2.new(0, 12, 0, 96)
revertBtn.BackgroundColor3 = Color3.fromRGB(110,110,110)
revertBtn.Text = "Revert"
revertBtn.Font = Enum.Font.GothamBold
revertBtn.TextSize = 14
revertBtn.TextColor3 = Color3.new(1,1,1)
revertBtn.Parent = controlsFrame
local revertCorner = Instance.new("UICorner", revertBtn)
revertCorner.CornerRadius = UDim.new(0,6)

-- Invite TextBox at bottom-left and NOT deletable
local inviteBox = Instance.new("TextBox")
inviteBox.Size = UDim2.new(0.72, 0, 0, 28) -- width will be updated to text size
inviteBox.Position = UDim2.new(0.06, 0, 1, -38)
inviteBox.BackgroundTransparency = 0.3
inviteBox.Text = DISCORD_INVITE
inviteBox.ClearTextOnFocus = false
inviteBox.Font = Enum.Font.Gotham
inviteBox.TextSize = 14
inviteBox.TextColor3 = Color3.new(1,1,1)
inviteBox.TextXAlignment = Enum.TextXAlignment.Left
inviteBox.Parent = mainFrame
local inviteCorner = Instance.new("UICorner", inviteBox)
inviteCorner.CornerRadius = UDim.new(0,6)

-- Auto-resize invite box width to text (last letter defines width)
local function resizeInviteBox()
    local pad = 18
    local size = TextService:GetTextSize(inviteBox.Text, inviteBox.TextSize, inviteBox.Font, Vector2.new(2000, 100))
    local newW = math.clamp(math.ceil(size.X) + pad, 100, FRAME_W - 80)
    inviteBox.Size = UDim2.new(0, newW, 0, 28)
    inviteBox.Position = UDim2.new(0.06, 0, 1, -38)
end
resizeInviteBox()

-- prevent user from deleting or changing invite text: if they edit, restore
inviteBox:GetPropertyChangedSignal("Text"):Connect(function()
    if inviteBox.Text ~= DISCORD_INVITE then
        inviteBox.Text = DISCORD_INVITE
        pcall(function()
            inviteBox:CaptureFocus()
            inviteBox.SelectionStart = 1
            inviteBox.CursorPosition = #inviteBox.Text + 1
        end)
        resizeInviteBox()
    end
end)

-- Clicking invite selects it (user copies manually)
inviteBox.MouseButton1Click:Connect(function()
    pcall(function()
        inviteBox:CaptureFocus()
        inviteBox.SelectionStart = 1
        inviteBox.CursorPosition = #inviteBox.Text + 1
    end)
end)

-- CLAMP helper
local function clampPositionToScreen(px, py)
    local camera = workspace.CurrentCamera
    if not camera then return px, py end
    local view = camera.ViewportSize
    local maxX = math.max(0, view.X - mainFrame.AbsoluteSize.X)
    local maxY = math.max(0, view.Y - mainFrame.AbsoluteSize.Y)
    local nx = math.clamp(px, 0, maxX)
    local ny = math.clamp(py, 0, maxY)
    return nx, ny
end

-- DRAG STICKER bottom-right (only thing that moves GUI)
local dragSticker = Instance.new("ImageButton")
dragSticker.Size = UDim2.new(0, 30, 0, 30)
dragSticker.Position = UDim2.new(1, -36, 1, -36)
dragSticker.AnchorPoint = Vector2.new(0,0)
dragSticker.BackgroundColor3 = Color3.fromRGB(70,70,70)
dragSticker.Image = ""
dragSticker.Parent = mainFrame
local dsCorner = Instance.new("UICorner", dragSticker)
dsCorner.CornerRadius = UDim.new(0,6)

local isDraggingGUI = false
local dragStartMouse = Vector2.new()
local dragStartPos = Vector2.new()

dragSticker.InputBegan:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
        isDraggingGUI = true
        local mpos = UserInputService:GetMouseLocation()
        dragStartMouse = Vector2.new(mpos.X, mpos.Y)
        dragStartPos = Vector2.new(mainFrame.AbsolutePosition.X, mainFrame.AbsolutePosition.Y)
        input.Changed:Connect(function()
            if input.UserInputState == Enum.UserInputState.End then
                isDraggingGUI = false
            end
        end)
    end
end)

UserInputService.InputChanged:Connect(function(input)
    if isDraggingGUI and input.UserInputType == Enum.UserInputType.MouseMovement then
        local m = UserInputService:GetMouseLocation()
        local delta = Vector2.new(m.X, m.Y) - dragStartMouse
        local newPos = dragStartPos + delta
        local nx, ny = clampPositionToScreen(newPos.X, newPos.Y)
        mainFrame.Position = UDim2.new(0, nx, 0, ny)
    end
end)

-- SLIDER LOGIC (continuous, snaps to SNAP units)
local function enableSliderDrag(slider)
    local track = slider.Track
    local knob = slider.Knob
    local dragging = false

    knob.InputBegan:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
            dragging = true
            slider.Dragging = true
        end
    end)

    knob.InputEnded:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
            dragging = false
            slider.Dragging = false
        end
    end)

    track.InputBegan:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
            local mx = UserInputService:GetMouseLocation().X
            local rel = math.clamp((mx - track.AbsolutePosition.X) / math.max(1, track.AbsoluteSize.X), 0, 1)
            local raw = rel * MAX_VALUE
            local value = math.floor((raw + SNAP/2) / SNAP) * SNAP
            slider.Value = value
            slider.Fill.Size = UDim2.new(value / MAX_VALUE, 0, 1, 0)
            slider.Knob.Position = UDim2.new(value / MAX_VALUE, 0, 0.5, 0)
            slider.SavedValue = value -- update saved valid
        end
    end)

    UserInputService.InputChanged:Connect(function(input)
        if dragging and input.UserInputType == Enum.UserInputType.MouseMovement then
            local mx = UserInputService:GetMouseLocation().X
            local rel = math.clamp((mx - track.AbsolutePosition.X) / math.max(1, track.AbsoluteSize.X), 0, 1)
            local raw = rel * MAX_VALUE
            local value = math.floor((raw + SNAP/2) / SNAP) * SNAP
            slider.Value = value
            slider.Fill.Size = UDim2.new(value / MAX_VALUE, 0, 1, 0)
            slider.Knob.Position = UDim2.new(value / MAX_VALUE, 0, 0.5, 0)
            slider.SavedValue = value -- update saved valid
        end
    end)
end

enableSliderDrag(speedRow)
enableSliderDrag(jumpRow)

-- TEXTBOX validation behavior: allow typing freely, validate only on FocusLost or Enter
local function sanitizeNumberString(s)
    local cleaned = s:gsub("%D", "")
    if cleaned == "" then return nil end
    return tonumber(cleaned)
end

local function hookValueBox(slider)
    local box = slider.ValueBox
    -- on focus lost validate and accept/revert
    box.FocusLost:Connect(function(enterPressed)
        local txt = box.Text or ""
        local num = sanitizeNumberString(txt)
        if not num then
            -- revert to saved valid value
            box.Text = tostring(math.floor(slider.SavedValue + 0.5))
            slider.Value = slider.SavedValue
            slider.Fill.Size = UDim2.new(slider.SavedValue / MAX_VALUE, 0, 1, 0)
            slider.Knob.Position = UDim2.new(slider.SavedValue / MAX_VALUE, 0, 0.5, 0)
            return
        end
        num = math.clamp(math.floor(num + 0.5), 0, MAX_VALUE)
        if num < 0 or num > MAX_VALUE then
            -- invalid -> revert
            box.Text = tostring(math.floor(slider.SavedValue + 0.5))
            slider.Value = slider.SavedValue
            slider.Fill.Size = UDim2.new(slider.SavedValue / MAX_VALUE, 0, 1, 0)
            slider.Knob.Position = UDim2.new(slider.SavedValue / MAX_VALUE, 0, 0.5, 0)
            return
        end
        -- valid: accept exact typed number, update saved
        slider.Value = num
        slider.SavedValue = num
        slider.Fill.Size = UDim2.new(num / MAX_VALUE, 0, 1, 0)
        slider.Knob.Position = UDim2.new(num / MAX_VALUE, 0, 0.5, 0)
        box.Text = tostring(num)
    end)
end

hookValueBox(speedRow)
hookValueBox(jumpRow)

-- APPLY values to humanoid (safe)
local function applyValues()
    local char = player.Character
    if not char then return end
    local hum = char:FindFirstChildOfClass("Humanoid")
    if not hum then return end
    if type(speedRow.Value) ~= "number" then speedRow.Value = DEFAULT_SPEED end
    if type(jumpRow.Value) ~= "number" then jumpRow.Value = DEFAULT_JUMP end
    hum.WalkSpeed = math.clamp(speedRow.Value, 0, MAX_VALUE)
    hum.JumpPower = math.clamp(jumpRow.Value, 0, MAX_VALUE)
    -- reflect integer display
    speedRow.ValueBox.Text = tostring(math.floor(speedRow.Value + 0.5))
    jumpRow.ValueBox.Text = tostring(math.floor(jumpRow.Value + 0.5))
end

-- REVERT
revertBtn.MouseButton1Click:Connect(function()
    speedRow.Value = DEFAULT_SPEED
    jumpRow.Value = DEFAULT_JUMP
    speedRow.SavedValue = DEFAULT_SPEED
    jumpRow.SavedValue = DEFAULT_JUMP
    speedRow.Fill.Size = UDim2.new(DEFAULT_SPEED / MAX_VALUE, 0, 1, 0)
    jumpRow.Fill.Size = UDim2.new(DEFAULT_JUMP / MAX_VALUE, 0, 1, 0)
    speedRow.Knob.Position = UDim2.new(DEFAULT_SPEED / MAX_VALUE, 0, 0.5, 0)
    jumpRow.Knob.Position = UDim2.new(DEFAULT_JUMP / MAX_VALUE, 0, 0.5, 0)
    applyValues()
end)

-- MINIMIZE
minBtn.MouseButton1Click:Connect(function()
    controlsFrame.Visible = not controlsFrame.Visible
    if controlsFrame.Visible then
        mainFrame.Size = UDim2.new(0, FRAME_W, 0, FRAME_H)
    else
        mainFrame.Size = UDim2.new(0, FRAME_W, 0, 40)
    end
end)

-- CLOSE
closeBtn.MouseButton1Click:Connect(function()
    screenGui:Destroy()
end)

-- Initialize visuals to defaults
speedRow.Value = speedRow.Value or DEFAULT_SPEED
jumpRow.Value = jumpRow.Value or DEFAULT_JUMP
speedRow.SavedValue = speedRow.SavedValue or speedRow.Value
jumpRow.SavedValue = jumpRow.SavedValue or jumpRow.Value
speedRow.Fill.Size = UDim2.new((speedRow.Value) / MAX_VALUE, 0, 1, 0)
jumpRow.Fill.Size = UDim2.new((jumpRow.Value) / MAX_VALUE, 0, 1, 0)
speedRow.Knob.Position = UDim2.new((speedRow.Value) / MAX_VALUE, 0, 0.5, 0)
jumpRow.Knob.Position = UDim2.new((jumpRow.Value) / MAX_VALUE, 0, 0.5, 0)
speedRow.ValueBox.Text = tostring(math.floor(speedRow.Value + 0.5))
jumpRow.ValueBox.Text = tostring(math.floor(jumpRow.Value + 0.5))

-- Main apply loop (lightweight)
local running = true
spawn(function()
    while running and screenGui.Parent do
        pcall(applyValues)
        wait(0.08)
    end
end)

-- Stop loop when GUI removed
screenGui.AncestryChanged:Connect(function()
    if not screenGui:IsDescendantOf(game) then running = false end
end)

-- Clamp position on render to keep inside screen
RunService:BindToRenderStep("ClampGUIPosition", Enum.RenderPriority.Camera.Value + 1, function()
    local pos = mainFrame.AbsolutePosition
    local nx, ny = clampPositionToScreen(pos.X, pos.Y)
    if nx ~= pos.X or ny ~= pos.Y then
        mainFrame.Position = UDim2.new(0, nx, 0, ny)
    end
end)
